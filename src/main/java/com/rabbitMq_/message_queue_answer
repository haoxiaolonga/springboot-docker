Q.为什么要使用消息队列，消息队列使用得场景？

answer:  传统的单机一把梭哈在业务体量没有上去的时候，不痛不痒。到后续业务量扩大，采用
    微服务的设计思想，分布式的部署方式，所以拆分了服务，那么单机的技术栈和中间件就不适用，
    对系统的友好性也下降了，所以通过消息队列中间件来辅助。
    经典场景： 异步、解耦、削峰。
   异步: 对于长链路调用的步骤，中间可以同时做的流程可以异步处理。
   解耦: 单纯的异步，线程池也能实现，但是由于全部写在一起耦合度很高，而且线程之间。
         存在问题：！！！ 分布式事务的问题。
   削峰： 将请求放到队里里面，根据服务器的处理能力限制每秒消费的多少，削减流量高峰，减轻服务器压力。

Q.消息队列存在的问题？

answer: 1.系统复杂度变高，维护难度升级需要考虑（重复消费，消息丢失，消息的顺序消费问题）
        2.数据一致性问题。
        3.可用性问题，MQ挂了，导致后续流程不执行。

Q.对比kafka、rabbitMQ、rocketMq、activeMq
answer：1.吞吐量：ActiveMq和rabbitMq都是万级，比rocketMq，kafka第一个数量级，后两者是（十万级，支持高吞吐。）
        2.topic对吞吐量的影响，前两者没有这个概念，rocketMQ较小的影响，roceket的优势，同等机器下，可以支撑大量的topic
          kafka在topic逐步增加的时候，吞吐量大幅下降，同等机器下，kafka尽量保证topic数量不要过多，如果需要大规模的topic-增加机器。
        3.时效性：
            activeMq:ms级；     rocketMq:ms级。    kafka：ms级以内。
            rabbitMq:微秒级-是rabbitMq的一大特点，延迟最低。
        4.可用性：
            activeMq和rabbitMq都是基于主从架构实现的高可用
            rocketMq和kafka是分布式架构。kafka(一个数据多个副本，少数机器宕机，不会导致不可用。)
        5.消息可靠性：
            activeMq:较低概率丢失数据、 rabbitMq基本不丢失。可以开启ack
            kafka和rocketMq经过参数优化配置，可以做到0丢失。（手动ack，配置每个leader必须有从节点，且每次必须所有副本都成功-一个操作才算成功。）
        6.功能支持：
            activeMQ：mq领域的功能极其完备
            rabbitMq: 基于erlang开发，并发性能好，延时性低
            rocketMQ:功能较为完善，分布式的扩展性好
            kafka：功能相对简单，常用在大数据领域的实时统计以及日志采集。
      选型时：主要考虑吞吐量，扩展性，以及使用场景。

Q.重复消费问题
answer: 1.接口幂等。
            强校验：例如金钱相关的场景，将需要的操作放到一个事务进行，每次消息过来用唯一标识去判断是否已做过处理，如果存在则直接return，否则执行逻辑。

            弱校验：例如不太重要的场景，发送短信等，把id+场景丢到redis，在一定时间内通过缓存校验。
Q.顺序消费问题
answer: 1.rocketMq 一个topic下有多个队列，为了保证发送顺序，提供了MessageQueueSelector队列选择机制。（hash,随机, 机房位置策略）
            选取Hash取模法可以保证同一个订单发送到同一个队列中，再使用同步发送，只有同一个订单的创建消息成功，再发送支付消息，保证有序，
            topic内部队列机制可以保证FIFO，所以只需要消费者顺序消费即可。

            同一个HASH过来也是一个消费者消费。（一个队列有序出去，一个消费者消费：但是考虑多线程消费，所以还是消费成功了一个再发下一个消息稳妥。）
Q.分布式事务的问题
answer: 1.事务的4属性ACID:
                atomicity:原子性 一个事务是不可分割的工作单位，事务中的操作要么全1，要么全0.
                consistency:一致性，事务必须使数据库从一个一致性状态变到一个一致性状态，和原子性密不可分。
                isolation:隔离性，事务的执行不受其他事务的影响，事务内部的操作和使用得数据对并发的事务是隔离的，互不干扰。
                durability:持久性，事务一旦提交成功，对数据的改变就是永久性的，接下来的操作对其不受影响。
        2.分布式事务--2PC 两阶段提交，TCC（try,confirm,cancel）,XA(senta的默认)，半消息/最终一致性（rocketMq）
        (一些问题点：长时间锁定资源，导致响应缓慢，或者出现数据不一致现象，单调故障，选举leader时问题，TCC的成本问题)
        2PC 过程：
            通过消息中间件MQ来协调系统，系统a先锁定资源不提交事务，通知MQ,mq通知系统b 锁定资源，不提交事务，准备成功告诉MQ
            mq告诉系统A可以提交，提交成功后，通知MQ然后告知系统B，系统B再提交事务。(弊端：最后B还是可能会失败。)
        最终一致性方案：
            推送方--发送消息给MQ,MQ持久化消息，返回状态（失败:不执行操作，成功：执行操作），推送方：发送处理结果
            MQ根据推送放结果，（成功:那么将消息状态调整为待发送，失败：则删除之前准备的消息。）--》最后消费消息，保证消息成功消费。
            最后达到最终一致性，要么都成功，或者都不执行。


















